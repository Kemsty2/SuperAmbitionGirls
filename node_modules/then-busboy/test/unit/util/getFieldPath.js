"use strict";

var _ava = _interopRequireDefault(require("ava"));

var _getFieldPath = _interopRequireDefault(require("../../../lib/util/getFieldPath"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _ava.default)("Should return an array with one element", t => {
  t.plan(2);
  const path = (0, _getFieldPath.default)("someElement");
  t.is(path.length, 1);
  t.deepEqual(path, ["someElement"]);
});
(0, _ava.default)("Should resolve more complex path", t => {
  t.plan(1);
  const expected = ["stories", 1, "chapters", 42];
  const actual = (0, _getFieldPath.default)("stories[1][chapters][42]");
  t.deepEqual(actual, expected);
});
(0, _ava.default)("Should throw an error when field name is not a string", t => {
  t.plan(3);

  const trap = () => (0, _getFieldPath.default)({});

  const err = t.throws(trap);
  t.true(err instanceof TypeError);
  t.is(err.message, "Field name should be a string. Received object");
});
(0, _ava.default)("Should throw a TypeError on invocation without any arguments", t => {
  t.plan(3);

  const trap = () => (0, _getFieldPath.default)();

  const err = t.throws(trap);
  t.true(err instanceof TypeError);
  t.is(err.message, "Field name should be a string. Received undefined");
});
(0, _ava.default)("Should throw an error when given field name is empty string", t => {
  t.plan(1);

  const trap = () => (0, _getFieldPath.default)("");

  t.throws(trap, "Field name cannot be empty.");
});
(0, _ava.default)("Should throw a TypeError on unallowed field name format", t => {
  t.plan(2);
  const format = "some[totally[]][wrong]format";

  const trap = () => (0, _getFieldPath.default)(format);

  const err = t.throws(trap);
  t.is(err.message, `Unexpected name format of the field: ${format}`);
});