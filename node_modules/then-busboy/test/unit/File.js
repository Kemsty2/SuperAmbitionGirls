"use strict";

var _stream = _interopRequireWildcard(require("stream"));

var _fs = require("fs");

var _path = require("path");

var _os = require("os");

var _ava = _interopRequireDefault(require("ava"));

var _proxyquire = _interopRequireDefault(require("proxyquire"));

var _nanoid = _interopRequireDefault(require("nanoid"));

var _sinon = require("sinon");

var _promiseFs = require("promise-fs");

var _File = _interopRequireDefault(require("../../lib/File"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

(0, _ava.default)("Should create a File with given stream and metadata", t => {
  t.plan(8);
  const contents = (0, _fs.createReadStream)(__filename);
  const filename = (0, _path.basename)(__filename);
  const ext = (0, _path.extname)(__filename);
  const base = (0, _path.basename)(__filename, ext);
  const file = new _File.default({
    contents,
    filename,
    mime: "text/javascript",
    enc: "utf-8"
  });
  t.true(file instanceof _File.default);
  t.true(file.contents instanceof _stream.default);
  t.true(file.stream instanceof _stream.default);
  t.is(file.mime, "text/javascript");
  t.is(file.enc, "utf-8");
  t.is(file.filename, filename);
  t.is(file.basename, base);
  t.is(file.extname, ext);
});
(0, _ava.default)("Should return a correct string on inspect call", t => {
  t.plan(1);
  const contents = (0, _fs.createReadStream)(__filename);
  const filename = (0, _path.basename)(__filename);
  const file = new _File.default({
    contents,
    filename,
    mime: "text/javascript",
    enc: "utf-8"
  });
  t.is(file.inspect(), `<File: ${filename}>`);
});
(0, _ava.default)("Should return a correct string on toJSON call", t => {
  t.plan(1);
  const contents = (0, _fs.createReadStream)(__filename);
  const filename = (0, _path.basename)(__filename);
  const file = new _File.default({
    contents,
    filename,
    mime: "text/javascript",
    enc: "utf-8"
  });
  t.is(file.inspect(), `<File: ${filename}>`);
});
(0, _ava.default)("Should return a correct string on JSON.stringify call", t => {
  t.plan(1);
  const contents = (0, _fs.createReadStream)(__filename);
  const filename = (0, _path.basename)(__filename);
  const file = new _File.default({
    contents,
    filename,
    mime: "text/javascript",
    enc: "utf-8"
  });
  t.is(JSON.stringify({
    file
  }), "{\"file\":\"<File: File.js>\"}");
});
(0, _ava.default)("Should have a correct default path", t => {
  const spyo = (0, _sinon.spy)(_nanoid.default);
  const spydir = (0, _sinon.spy)(_os.tmpdir);
  const MockedFile = (0, _proxyquire.default)("../../lib/File", {
    nanoid: spyo,
    os: {
      tmpdir: spydir
    }
  }).default;
  const contents = (0, _fs.createReadStream)(__filename);
  const filename = (0, _path.basename)(__filename);
  const file = new MockedFile({
    contents,
    filename,
    mime: "text/javascript",
    enc: "utf-8"
  });
  const expected = (0, _path.join)(spydir.lastCall.returnValue, `${spyo.lastCall.returnValue}_${filename}`);
  t.is(file.path, expected);
});
(0, _ava.default)("Should correctly read given file from Stream", async t => {
  t.plan(1);
  const contents = (0, _fs.createReadStream)(__filename);
  const filename = (0, _path.basename)(__filename);
  const file = new _File.default({
    contents,
    filename,
    mime: "text/javascript",
    enc: "utf-8"
  });
  const expected = await (0, _promiseFs.readFile)(__filename);
  const actual = await file.read();
  t.true(actual.equals(expected));
});
(0, _ava.default)("Should write file to disk", async t => {
  t.plan(1);
  const noop = (0, _sinon.spy)();

  function createWriteStream(path, options) {
    const bufs = [];
    let len = 0;

    function write(ch, enc, cb) {
      bufs.push(ch);
      len += ch.length;
      noop(path, Buffer.concat(bufs, len), cb);
    }

    const stream = new _stream.Writable(Object.assign({}, options, {
      write
    }));
    return stream;
  }

  const MockedFile = (0, _proxyquire.default)("../../lib/File", {
    fs: {
      createWriteStream
    }
  }).default;
  const expected = await (0, _promiseFs.readFile)(__filename);
  const contents = (0, _fs.createReadStream)(__filename);
  const filename = (0, _path.basename)(__filename);
  const file = new MockedFile({
    contents,
    filename,
    mime: "text/javascript",
    enc: "utf-8"
  });
  await file.write();
  const actual = noop.lastCall.args[1];
  t.true(actual.equals(expected));
});
(0, _ava.default)("Should write file to given path", async t => {
  t.plan(1);
  const noop = (0, _sinon.spy)();

  function createWriteStream(path, options) {
    const write = () => void noop(path);

    const stream = new _stream.Writable(Object.assign({}, options, {
      write
    }));
    return stream;
  }

  const MockedFile = (0, _proxyquire.default)("../../lib/File", {
    fs: {
      createWriteStream
    }
  }).default;
  const expected = "some/whatever/path";
  const contents = (0, _fs.createReadStream)(__filename);
  const filename = (0, _path.basename)(__filename);
  const file = new MockedFile({
    contents,
    filename,
    mime: "text/javascript",
    enc: "utf-8"
  });
  await file.write(expected);
  const [actual] = noop.lastCall.args;
  t.is(actual, expected);
});
(0, _ava.default)("Should throw an error when no contents given", t => {
  t.plan(3);

  const trap = () => new _File.default({});

  const err = t.throws(trap);
  t.true(err instanceof Error);
  t.is(err.message, "File contents required.");
});
(0, _ava.default)("Should throw an error when contents is not a Stream", t => {
  t.plan(3);

  const trap = () => new _File.default({
    contents: "Winter is coming..."
  });

  const err = t.throws(trap);
  t.true(err instanceof TypeError);
  t.is(err.message, "Contents should be a Stream. Received string");
});
(0, _ava.default)("Should throw an error when no filename given", t => {
  t.plan(1);
  const contents = (0, _fs.createReadStream)(__filename);

  const trap = () => new _File.default({
    contents
  });

  t.throws(trap, "Filename required.");
});
(0, _ava.default)("Should throw an error when filename is not a string", t => {
  t.plan(1);
  const contents = (0, _fs.createReadStream)(__filename);

  const trap = () => new _File.default({
    contents,
    filename: 42
  });

  t.throws(trap, "Filename should be a string. Received number");
});
(0, _ava.default)("Should throw an error when no enc given", t => {
  t.plan(1);
  const contents = (0, _fs.createReadStream)(__filename);

  const trap = () => new _File.default({
    contents,
    filename: (0, _path.basename)(__filename)
  });

  t.throws(trap, "File encoding required.");
});
(0, _ava.default)("Should throw an error when enc is not a string", t => {
  t.plan(1);
  const contents = (0, _fs.createReadStream)(__filename);

  const trap = () => new _File.default({
    contents,
    filename: (0, _path.basename)(__filename),
    enc: []
  });

  t.throws(trap, "File encoding should be a string. Received array");
});
(0, _ava.default)("Should throw an error when no mime given", t => {
  t.plan(1);
  const contents = (0, _fs.createReadStream)(__filename);

  const trap = () => new _File.default({
    contents,
    filename: (0, _path.basename)(__filename),
    enc: "utf-8"
  });

  t.throws(trap, "File mime type required.");
});
(0, _ava.default)("Should throw an error when mime is not a string", t => {
  t.plan(1);
  const contents = (0, _fs.createReadStream)(__filename);

  const trap = () => new _File.default({
    contents,
    filename: (0, _path.basename)(__filename),
    enc: "utf-8",
    mime: /.*/
  });

  t.throws(trap, "File mime type should be a string. Received RegExp");
});